{"version":3,"file":"main.js","mappings":";;;;;;;;;;AAAa;AACb;AACA,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA;AACA,cAAc,6BAA6B,0BAA0B,cAAc,qBAAqB;AACxG,iBAAiB,oDAAoD,qEAAqE,cAAc;AACxJ,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC,mCAAmC,SAAS;AAC5C,mCAAmC,WAAW,UAAU;AACxD,0CAA0C,cAAc;AACxD;AACA,8GAA8G,OAAO;AACrH,iFAAiF,iBAAiB;AAClG,yDAAyD,gBAAgB,QAAQ;AACjF,+CAA+C,gBAAgB,gBAAgB;AAC/E;AACA,kCAAkC;AAClC;AACA;AACA,UAAU,YAAY,aAAa,SAAS,UAAU;AACtD,oCAAoC,SAAS;AAC7C;AACA;AACA,kBAAkB;AAClB,sBAAsB,mBAAO,CAAC,qEAAsB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;AACD,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;;;;ACtKD;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC,SAAS;AACT;AACA;;AAEA,saAAsa,6BAA6B,qGAAqG,sEAAsE,wEAAwE,6BAA6B,uEAAuE,kCAAkC,4CAA4C,kKAAkK,0DAA0D,4BAA4B,sCAAsC,qLAAqL,2EAA2E,ySAAyS,aAAa,aAAa,OAAO,0BAA0B,kBAAkB,mCAAmC,yMAAyM,kCAAkC,yCAAyC,8CAA8C,SAAS,aAAa,0DAA0D,GAAG;;AAEprE;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;;AAEA,kaAAka,6BAA6B,qGAAqG,iQAAiQ,uEAAuE,6BAA6B,uEAAuE,iCAAiC,4CAA4C,2QAA2Q,8DAA8D,sCAAsC,YAAY,mEAAmE,4BAA4B,4BAA4B,sCAAsC,wQAAwQ,aAAa,aAAa,OAAO,mFAAmF,yFAAyF,0GAA0G,QAAQ,2BAA2B,sEAAsE,6LAA6L,0DAA0D,WAAW,IAAI,sBAAsB,6BAA6B,cAAc,yCAAyC,oFAAoF,QAAQ,2CAA2C,0ZAA0Z,GAAG;;AAErnG,sEAAsE,mBAAmB,kFAAkF,8EAA8E,oDAAoD,yFAAyF,uEAAuE,2DAA2D,wEAAwE,oBAAoB,oFAAoF,+EAA+E,iFAAiF,oDAAoD,wDAAwD,8BAA8B,yCAAyC,SAAS,KAAK,SAAS,GAAG,WAAW,GAAG,aAAa,GAAG,uBAAuB,IAAI,mBAAmB,2BAA2B,qCAAqC,4DAA4D,uBAAuB,IAAI,mBAAmB,+CAA+C,mEAAmE,mBAAmB,gBAAgB,YAAY,EAAE,qDAAqD,4BAA4B,QAAQ,qDAAqD,+DAA+D,6FAA6F,wDAAwD,QAAQ,gDAAgD,2BAA2B,uEAAuE,8CAA8C,iDAAiD,qCAAqC,aAAa,oBAAoB,0FAA0F,0CAA0C,aAAa,wBAAwB,wBAAwB,mBAAmB,wBAAwB,qCAAqC,aAAa,qBAAqB,aAAa,GAAG,mBAAmB,eAAe,8CAA8C,iDAAiD,oCAAoC,aAAa,YAAY,+DAA+D,aAAa,YAAY,8CAA8C,0CAA0C,mBAAmB,MAAM,oEAAoE,aAAa,WAAW,iFAAiF,2BAA2B,0CAA0C,wBAAwB,mBAAmB,wBAAwB,oCAAoC,aAAa,oBAAoB,aAAa,GAAG,mBAAmB,eAAe,WAAW,EAAE,uBAAuB,QAAQ,iDAAiD,uEAAuE,8CAA8C,2EAA2E,eAAe,mDAAmD,4EAA4E,8CAA8C,eAAe,oBAAoB,2DAA2D,MAAM,GAAG,eAAe,8BAA8B,WAAW,MAAM,2GAA2G,6CAA6C,8CAA8C,uEAAuE,eAAe,mDAAmD,mEAAmE,gFAAgF,eAAe,WAAW,EAAE,gCAAgC,QAAQ,uDAAuD,uFAAuF,iGAAiG,6BAA6B,gEAAgE,4EAA4E,kFAAkF,eAAe,kFAAkF,2FAA2F,kEAAkE,eAAe,WAAW,EAAE,yBAAyB,QAAQ,uDAAuD,kEAAkE,yCAAyC,4FAA4F,WAAW,EAAE,qCAAqC,QAAQ,gEAAgE,wFAAwF,gDAAgD,0BAA0B,qBAAqB,MAAM,8EAA8E,WAAW,6CAA6C,QAAQ,sEAAsE,+CAA+C,0EAA0E,gDAAgD,6EAA6E,0BAA0B,mBAAmB,MAAM,qEAAqE,WAAW,6CAA6C,QAAQ,gEAAgE,iDAAiD,kEAAkE,+JAA+J,QAAQ,+CAA+C,iDAAiD,kCAAkC,6HAA6H,kEAAkE,oCAAoC,0BAA0B,sCAAsC,2FAA2F,WAAW,iFAAiF,QAAQ,8CAA8C,mDAAmD,uIAAuI,0BAA0B,YAAY,uEAAuE,yBAAyB,QAAQ,8CAA8C,mDAAmD,kEAAkE,mFAAmF,yBAAyB,QAAQ,0EAA0E,sFAAsF,oCAAoC,4DAA4D,wCAAwC,sCAAsC,8CAA8C,kEAAkE,sEAAsE,0CAA0C,oDAAoD,wCAAwC,kCAAkC,uDAAuD,aAAa,EAAE,uBAAuB,KAAK,IAAI,EAAE;;AAEprR,qDAAqD;;AAErD;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,6CAA6C,yBAAyB;AACtE;AACA;AACA;;AAE+E;AAC/E;;;;;;;UCnDA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;UENA;UACA;UACA;UACA","sources":["webpack://audioworklets/./src/index.ts","webpack://audioworklets/../../WebPd_audioworklets/dist/index.js","webpack://audioworklets/webpack/bootstrap","webpack://audioworklets/webpack/runtime/define property getters","webpack://audioworklets/webpack/runtime/hasOwnProperty shorthand","webpack://audioworklets/webpack/runtime/make namespace object","webpack://audioworklets/webpack/before-startup","webpack://audioworklets/webpack/startup","webpack://audioworklets/webpack/after-startup"],"sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nexports.__esModule = true;\nvar audioworklets_1 = require(\"@webpd/audioworklets\");\nvar BIT_DEPTH = 64;\nvar CHANNEL_COUNT = 1;\nvar WASM_PATCHES = {\n    'osc': null,\n    'play-array': null\n};\nvar SAMPLES = {\n    'audio1': null\n};\nvar startButton = document.querySelector('button#start');\nvar patchesDiv = document.querySelector('div#patches');\nvar context = new AudioContext();\nvar wasmNode;\nvar initializeApp = function () { return __awaiter(void 0, void 0, void 0, function () {\n    var patchNames, _i, patchNames_1, name_1, _a, _b, button, sampleNames, _c, sampleNames_1, name_2, _d, _e;\n    return __generator(this, function (_f) {\n        switch (_f.label) {\n            case 0: return [4 /*yield*/, (0, audioworklets_1.addModule)(context, audioworklets_1.audioworkletWasm.WorkletProcessorCode)\n                // Load wasm patches\n            ];\n            case 1:\n                _f.sent();\n                patchNames = Object.keys(WASM_PATCHES);\n                _i = 0, patchNames_1 = patchNames;\n                _f.label = 2;\n            case 2:\n                if (!(_i < patchNames_1.length)) return [3 /*break*/, 5];\n                name_1 = patchNames_1[_i];\n                _a = WASM_PATCHES;\n                _b = name_1;\n                return [4 /*yield*/, loadWasmPatch(name_1)];\n            case 3:\n                _a[_b] = _f.sent();\n                button = document.createElement('button');\n                button.innerHTML = name_1;\n                button.onclick = (function (name) {\n                    return function () {\n                        setWasmPatch(name);\n                    };\n                })(name_1);\n                patchesDiv.appendChild(button);\n                _f.label = 4;\n            case 4:\n                _i++;\n                return [3 /*break*/, 2];\n            case 5:\n                sampleNames = Object.keys(SAMPLES);\n                _c = 0, sampleNames_1 = sampleNames;\n                _f.label = 6;\n            case 6:\n                if (!(_c < sampleNames_1.length)) return [3 /*break*/, 9];\n                name_2 = sampleNames_1[_c];\n                _d = SAMPLES;\n                _e = name_2;\n                return [4 /*yield*/, loadAudioSample(name_2)];\n            case 7:\n                _d[_e] = _f.sent();\n                _f.label = 8;\n            case 8:\n                _c++;\n                return [3 /*break*/, 6];\n            case 9: return [2 /*return*/];\n        }\n    });\n}); };\nvar startAudio = function () {\n    context.resume();\n    wasmNode = new audioworklets_1.audioworkletWasm.WorkletNode(context, CHANNEL_COUNT, BIT_DEPTH);\n    wasmNode.connect(context.destination);\n    startButton.style.display = 'none';\n};\nvar loadWasmPatch = function (name) { return __awaiter(void 0, void 0, void 0, function () {\n    var url, response;\n    return __generator(this, function (_a) {\n        switch (_a.label) {\n            case 0:\n                url = \"assets/wasm/\".concat(name, \".wasm\");\n                return [4 /*yield*/, fetch(url)];\n            case 1:\n                response = _a.sent();\n                if (!response.ok) {\n                    throw new Error(\"unvalid response for \".concat(url, \": \").concat(response.status));\n                }\n                return [2 /*return*/, response.arrayBuffer()];\n        }\n    });\n}); };\nvar loadAudioSample = function (name) { return __awaiter(void 0, void 0, void 0, function () {\n    var url, response, audioData, audioBuffer;\n    return __generator(this, function (_a) {\n        switch (_a.label) {\n            case 0:\n                url = \"assets/audio/\".concat(name, \".mp3\");\n                return [4 /*yield*/, fetch(url)];\n            case 1:\n                response = _a.sent();\n                if (!response.ok) {\n                    throw new Error(\"unvalid response for \".concat(url, \": \").concat(response.status));\n                }\n                return [4 /*yield*/, response.arrayBuffer()];\n            case 2:\n                audioData = _a.sent();\n                return [4 /*yield*/, context.decodeAudioData(audioData)\n                    // !!! Loading only first channel of stereo audio\n                ];\n            case 3:\n                audioBuffer = _a.sent();\n                // !!! Loading only first channel of stereo audio\n                return [2 /*return*/, Float64Array.from(audioBuffer.getChannelData(0))];\n        }\n    });\n}); };\nvar setWasmPatch = function (name) {\n    var wasmPatch = WASM_PATCHES[name];\n    if (wasmPatch) {\n        console.log(\"set wasm patch \".concat(name, \" : byte length \").concat(wasmPatch.byteLength));\n        wasmNode === null || wasmNode === void 0 ? void 0 : wasmNode.port.postMessage({\n            type: 'WASM', payload: {\n                wasmBuffer: wasmPatch, arrays: SAMPLES\n            }\n        });\n    }\n};\ninitializeApp().then(function () {\n    startButton.style.display = 'block';\n    startButton.onclick = startAudio;\n    console.log(\"audio initialized\");\n});\n","class JsEvalNode extends AudioWorkletNode {\n    constructor(context, channelCount) {\n        super(context, 'js-eval-node', {\n            numberOfOutputs: 1,\n            outputChannelCount: [channelCount],\n            processorOptions: {},\n        });\n    }\n}\n\nvar _WorkletProcessorCode$1 = \"/*\\n * Copyright (c) 2012-2020 Sébastien Piquemal <sebpiq@gmail.com>\\n *\\n * BSD Simplified License.\\n * For information on usage and redistribution, and for a DISCLAIMER OF ALL\\n * WARRANTIES, see the file, \\\"LICENSE.txt,\\\" in this distribution.\\n *\\n * See https://github.com/sebpiq/WebPd_pd-parser for documentation\\n *\\n */\\n\\nclass JsEvalWorkletProcessor extends AudioWorkletProcessor {\\n    constructor(settings) {\\n        super()\\n        this.port.onmessage = this.onMessage.bind(this)\\n        this.settings = {\\n            channelCount: settings.outputChannelCount[0],\\n        }\\n        this.dspLoop = null\\n        this.dspConfigured = false\\n    }\\n\\n    process(_, outputs) {\\n        const output = outputs[0]\\n        if (!this.dspConfigured) {\\n            if (!this.dspLoop) {\\n                return true\\n            }\\n            this.settings.blockSize = output[0].length\\n            this.dspConfigure(this.settings.blockSize)\\n            this.dspConfigured = true\\n        }\\n        this.dspLoop(output)\\n        return true\\n    }\\n\\n    onMessage(message) {\\n        switch (message.data.type) {\\n            case 'CODE':\\n                this.setDspCode(message.data.payload.code)\\n                Object.entries(message.data.payload.arrays).forEach(([arrayName, array]) => {\\n                    this.dspSetArray(arrayName, array)\\n                })\\n                break\\n            case 'PORT':\\n                this.callPort(\\n                    message.data.payload.portName,\\n                    message.data.payload.args\\n                )\\n                break\\n            default:\\n                new Error(`unknown message type ${message.type}`)\\n        }\\n    }\\n\\n    setDspCode(code) {\\n        const { loop, ports, configure, setArray } = new Function(code)()\\n        this.dspConfigured = false\\n        this.dspConfigure = configure\\n        this.dspLoop = loop\\n        this.dspPorts = ports\\n        this.dspSetArray = setArray\\n    }\\n\\n    callPort(portName, args) {\\n        if (!this.dspPorts[portName]) {\\n            throw new Error(`Unknown port ${portName}`)\\n        }\\n        this.dspPorts[portName].apply(this, args)\\n    }\\n}\\n\\nregisterProcessor('js-eval-node', JsEvalWorkletProcessor)\\n\";\n\nconst WorkletProcessorCode$1 = _WorkletProcessorCode$1;\n\nvar index$1 = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    WorkletProcessorCode: WorkletProcessorCode$1,\n    WorkletNode: JsEvalNode\n});\n\nclass WasmWorkletNode extends AudioWorkletNode {\n    constructor(context, channelCount, bitDepth = 32) {\n        super(context, 'wasm-node', {\n            numberOfOutputs: 1,\n            outputChannelCount: [channelCount],\n            processorOptions: {\n                bitDepth, sampleRate: context.sampleRate\n            },\n        });\n    }\n}\n\nvar _WorkletProcessorCode = \"/*\\n * Copyright (c) 2012-2020 Sébastien Piquemal <sebpiq@gmail.com>\\n *\\n * BSD Simplified License.\\n * For information on usage and redistribution, and for a DISCLAIMER OF ALL\\n * WARRANTIES, see the file, \\\"LICENSE.txt,\\\" in this distribution.\\n *\\n * See https://github.com/sebpiq/WebPd_pd-parser for documentation\\n *\\n */\\n\\nclass WasmWorkletProcessor extends AudioWorkletProcessor {\\n    constructor(settings) {\\n        super()\\n        this.port.onmessage = this.onMessage.bind(this)\\n        this.settings = {\\n            blockSize: null,\\n            channelCount: settings.outputChannelCount[0],\\n            bitDepth:\\n                settings.processorOptions.bitDepth,\\n            sampleRate: \\n                settings.processorOptions.sampleRate,\\n        }\\n        this.dspConfigured = false\\n        this.engine = null\\n    }\\n\\n    process(_, outputs) {\\n        const output = outputs[0]\\n        if (!this.dspConfigured) {\\n            if (!this.engine) {\\n                return true\\n            }\\n            this.settings.blockSize = output[0].length\\n            this.wasmOutputPointer = this.engine.configure(\\n                this.settings.sampleRate,\\n                this.settings.blockSize,\\n            )\\n            this.dspConfigured = true\\n        }\\n\\n        this.engine.loop()\\n        for (let channel = 0; channel < this.settings.channelCount; channel++) {\\n            this.readChannel(channel, output[channel])\\n        }\\n        return true\\n    }\\n\\n    onMessage(message) {\\n        switch (message.data.type) {\\n            case 'WASM':\\n                this.setWasm(message.data.payload.wasmBuffer)\\n                    .then(() => this.setArrays(message.data.payload.arrays))\\n                break\\n            default:\\n                new Error(`unknown message type ${message.type}`)\\n        }\\n    }\\n\\n    // TODO : control for channelCount of wasmModule\\n    setWasm(wasmBuffer) {\\n        return AscWasmBindings.instantiateWasmModule(wasmBuffer).then((wasmModule) => {\\n            this.engine = wasmModule.instance.exports\\n            this.dspConfigured = false\\n        })\\n    }\\n\\n    setArrays(arrays) {\\n        Object.entries(arrays).forEach(([arrayName, arrayData]) => {\\n            if ((this.settings.bitDepth === 32 && arrayData.constructor !== Float32Array) \\n                || (this.settings.bitDepth === 64 && arrayData.constructor !== Float64Array)) {\\n                console.error(`Received invalid array ${arrayName} : ${arrayData.constructor}, wrong type for bit-depth ${this.bitDepth}`)\\n                return\\n            }\\n            AscWasmBindings.setArray(this.engine, arrayName, arrayData)\\n        })\\n    }\\n\\n    readChannel(channel, destination) {\\n        const wasmOutput = AscWasmBindings.liftTypedArray(\\n            this.engine,\\n            this.settings.bitDepth === 32 ? Float32Array : Float64Array,\\n            this.wasmOutputPointer,\\n        )\\n        destination.set(\\n            wasmOutput.subarray(\\n                this.settings.blockSize * channel,\\n                this.settings.blockSize * (channel + 1)\\n            )\\n        )\\n    }\\n}\\n\\nregisterProcessor('wasm-node', WasmWorkletProcessor)\\n\";\n\nvar AcmWasmBindingsCode = \"var AscWasmBindings = (function (exports) {\\n    'use strict';\\n\\n    const MESSAGE_DATUM_TYPE_STRING = Symbol.for('MESSAGE_DATUM_TYPE_STRING');\\n    const MESSAGE_DATUM_TYPE_FLOAT = Symbol.for('MESSAGE_DATUM_TYPE_FLOAT');\\n\\n    const MESSAGE_DATUM_TYPES_ASSEMBLYSCRIPT = {\\n        [MESSAGE_DATUM_TYPE_FLOAT]: 0,\\n        [MESSAGE_DATUM_TYPE_STRING]: 1,\\n    };\\n    const INT_ARRAY_BYTES_PER_ELEMENT = Int32Array.BYTES_PER_ELEMENT;\\n    const instantiateWasmModule = async (wasmBuffer) => {\\n        const wasmModule = await WebAssembly.instantiate(wasmBuffer, {\\n            env: {\\n                abort(messagePointer, fileNamePointer, lineNumber, columnNumber) {\\n                    const message = liftString(engine, messagePointer >>> 0);\\n                    const fileName = liftString(engine, fileNamePointer >>> 0);\\n                    lineNumber = lineNumber >>> 0;\\n                    columnNumber = columnNumber >>> 0;\\n                    (() => {\\n                        throw Error(`${message} in ${fileName}:${lineNumber}:${columnNumber}`);\\n                    })();\\n                },\\n                seed() {\\n                    return (() => {\\n                        return Date.now() * Math.random();\\n                    })();\\n                },\\n                'console.log'(textPointer) {\\n                    console.log(liftString(engine, textPointer));\\n                },\\n            },\\n        });\\n        const engine = wasmModule.instance.exports;\\n        return wasmModule;\\n    };\\n    const setArray = (engine, arrayName, data) => {\\n        const stringPointer = lowerString(engine, arrayName);\\n        const bufferPointer = lowerArrayBufferOfFloats(engine, data, engine.getBitDepth());\\n        engine.setArray(stringPointer, bufferPointer);\\n    };\\n    const bindPorts = (engine, portSpecs) => {\\n        const ports = {};\\n        Object.entries(portSpecs).forEach(([variableName, spec]) => {\\n            if (spec.access.includes('w')) {\\n                if (spec.type === 'messages') {\\n                    ports[`write_${variableName}`] = (messages) => {\\n                        const messageArrayPointer = lowerMessageArray(engine, messages);\\n                        engine[`write_${variableName}`](messageArrayPointer);\\n                    };\\n                }\\n                else {\\n                    ports[`write_${variableName}`] = engine[`write_${variableName}`];\\n                }\\n            }\\n            if (spec.access.includes('r')) {\\n                if (spec.type === 'messages') {\\n                    ports[`read_${variableName}`] = () => {\\n                        const messagesCount = engine[`read_${variableName}_length`]();\\n                        const messages = [];\\n                        for (let i = 0; i < messagesCount; i++) {\\n                            const messagePointer = engine[`read_${variableName}_elem`](i);\\n                            messages.push(liftMessage(engine, messagePointer));\\n                        }\\n                        return messages;\\n                    };\\n                }\\n                else {\\n                    ports[`read_${variableName}`] = engine[`read_${variableName}`];\\n                }\\n            }\\n        });\\n        return ports;\\n    };\\n    const lowerMessage = (engine, message) => {\\n        const messageTemplate = message.reduce((template, value) => {\\n            if (typeof value === 'number') {\\n                template.push(engine.MESSAGE_DATUM_TYPE_FLOAT.valueOf());\\n            }\\n            else if (typeof value === 'string') {\\n                template.push(engine.MESSAGE_DATUM_TYPE_STRING.valueOf());\\n                template.push(value.length);\\n            }\\n            else {\\n                throw new Error(`invalid message value ${value}`);\\n            }\\n            return template;\\n        }, []);\\n        const messagePointer = engine.createMessage(lowerArrayBufferOfIntegers(engine, messageTemplate));\\n        message.forEach((value, index) => {\\n            if (typeof value === 'number') {\\n                engine.writeFloatDatum(messagePointer, index, value);\\n            }\\n            else if (typeof value === 'string') {\\n                const stringPointer = lowerString(engine, value);\\n                engine.writeStringDatum(messagePointer, index, stringPointer);\\n            }\\n        });\\n        return messagePointer;\\n    };\\n    const liftMessage = (engine, messagePointer) => {\\n        const messageDatumTypesPointer = engine.getMessageDatumTypes(messagePointer);\\n        const messageDatumTypes = liftTypedArray(engine, Int32Array, messageDatumTypesPointer);\\n        const message = [];\\n        messageDatumTypes.forEach((datumType, datumIndex) => {\\n            if (datumType === engine.MESSAGE_DATUM_TYPE_FLOAT.valueOf()) {\\n                message.push(engine.readFloatDatum(messagePointer, datumIndex));\\n            }\\n            else if (datumType === engine.MESSAGE_DATUM_TYPE_STRING.valueOf()) {\\n                const stringPointer = engine.readStringDatum(messagePointer, datumIndex);\\n                message.push(liftString(engine, stringPointer));\\n            }\\n        });\\n        return message;\\n    };\\n    const lowerMessageArray = (engine, messages) => {\\n        const messageArrayPointer = engine.createMessageArray();\\n        messages.forEach((message) => {\\n            engine.pushMessageToArray(messageArrayPointer, lowerMessage(engine, message));\\n        });\\n        return messageArrayPointer;\\n    };\\n    const lowerArrayBufferOfIntegers = (engine, integers) => {\\n        const buffer = new ArrayBuffer(INT_ARRAY_BYTES_PER_ELEMENT * integers.length);\\n        const dataView = new DataView(buffer);\\n        for (let i = 0; i < integers.length; i++) {\\n            dataView.setInt32(INT_ARRAY_BYTES_PER_ELEMENT * i, integers[i]);\\n        }\\n        return lowerBuffer(engine, buffer);\\n    };\\n    const lowerArrayBufferOfFloats = (engine, floats, bitDepth) => {\\n        const bytesPerElement = bitDepth / 8;\\n        const buffer = new ArrayBuffer(bytesPerElement * floats.length);\\n        const dataView = new DataView(buffer);\\n        const setFloatName = bitDepth === 32 ? 'setFloat32' : 'setFloat64';\\n        for (let i = 0; i < floats.length; i++) {\\n            dataView[setFloatName](bytesPerElement * i, floats[i]);\\n        }\\n        return lowerBuffer(engine, buffer);\\n    };\\n    const liftTypedArray = (engine, constructor, pointer) => {\\n        if (!pointer)\\n            return null;\\n        const memoryU32 = new Uint32Array(engine.memory.buffer);\\n        return new constructor(engine.memory.buffer, memoryU32[(pointer + 4) >>> 2], memoryU32[(pointer + 8) >>> 2] / constructor.BYTES_PER_ELEMENT).slice();\\n    };\\n    const liftString = (engine, pointer) => {\\n        if (!pointer)\\n            return null;\\n        pointer = pointer >>> 0;\\n        const end = (pointer +\\n            new Uint32Array(engine.memory.buffer)[(pointer - 4) >>> 2]) >>>\\n            1;\\n        const memoryU16 = new Uint16Array(engine.memory.buffer);\\n        let start = pointer >>> 1;\\n        let string = '';\\n        while (end - start > 1024) {\\n            string += String.fromCharCode(...memoryU16.subarray(start, (start += 1024)));\\n        }\\n        return string + String.fromCharCode(...memoryU16.subarray(start, end));\\n    };\\n    const lowerString = (engine, value) => {\\n        if (value == null)\\n            return 0;\\n        const length = value.length, pointer = engine.__new(length << 1, 1) >>> 0, memoryU16 = new Uint16Array(engine.memory.buffer);\\n        for (let i = 0; i < length; ++i)\\n            memoryU16[(pointer >>> 1) + i] = value.charCodeAt(i);\\n        return pointer;\\n    };\\n    const lowerBuffer = (engine, value) => {\\n        if (value == null)\\n            return 0;\\n        const pointer = engine.__new(value.byteLength, 0) >>> 0;\\n        new Uint8Array(engine.memory.buffer).set(new Uint8Array(value), pointer);\\n        return pointer;\\n    };\\n\\n    exports.INT_ARRAY_BYTES_PER_ELEMENT = INT_ARRAY_BYTES_PER_ELEMENT;\\n    exports.MESSAGE_DATUM_TYPES_ASSEMBLYSCRIPT = MESSAGE_DATUM_TYPES_ASSEMBLYSCRIPT;\\n    exports.bindPorts = bindPorts;\\n    exports.instantiateWasmModule = instantiateWasmModule;\\n    exports.liftMessage = liftMessage;\\n    exports.liftString = liftString;\\n    exports.liftTypedArray = liftTypedArray;\\n    exports.lowerArrayBufferOfFloats = lowerArrayBufferOfFloats;\\n    exports.lowerArrayBufferOfIntegers = lowerArrayBufferOfIntegers;\\n    exports.lowerMessage = lowerMessage;\\n    exports.lowerMessageArray = lowerMessageArray;\\n    exports.lowerString = lowerString;\\n    exports.setArray = setArray;\\n\\n    Object.defineProperty(exports, '__esModule', { value: true });\\n\\n    return exports;\\n\\n})({});\\n//# sourceMappingURL=asc-wasm-bindings.iife.js.map\\n\";\n\nconst WorkletProcessorCode = AcmWasmBindingsCode + ';\\n' + _WorkletProcessorCode;\n\nvar index = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    WorkletProcessorCode: WorkletProcessorCode,\n    WorkletNode: WasmWorkletNode\n});\n\nconst addModule = async (context, processorCode) => {\n    const blob = new Blob([processorCode], { type: 'text/javascript' });\n    const workletProcessorUrl = URL.createObjectURL(blob);\n    return context.audioWorklet.addModule(workletProcessorUrl);\n};\n\nexport { addModule, index$1 as audioworkletJsEval, index as audioworkletWasm };\n//# sourceMappingURL=index.js.map\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./src/index.ts\");\n",""],"names":[],"sourceRoot":""}
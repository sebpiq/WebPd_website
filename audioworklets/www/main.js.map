{"version":3,"file":"main.js","mappings":";;;;;;;;;;AAAa;AACb;AACA,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA;AACA,cAAc,6BAA6B,0BAA0B,cAAc,qBAAqB;AACxG,iBAAiB,oDAAoD,qEAAqE,cAAc;AACxJ,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC,mCAAmC,SAAS;AAC5C,mCAAmC,WAAW,UAAU;AACxD,0CAA0C,cAAc;AACxD;AACA,8GAA8G,OAAO;AACrH,iFAAiF,iBAAiB;AAClG,yDAAyD,gBAAgB,QAAQ;AACjF,+CAA+C,gBAAgB,gBAAgB;AAC/E;AACA,kCAAkC;AAClC;AACA;AACA,UAAU,YAAY,aAAa,SAAS,UAAU;AACtD,oCAAoC,SAAS;AAC7C;AACA;AACA,kBAAkB;AAClB,sBAAsB,mBAAO,CAAC,qEAAsB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;AACD,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;AACD;AACA;A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","sources":["webpack://audioworklets/./src/index.ts","webpack://audioworklets/../../WebPd_audioworklets/dist/index.js","webpack://audioworklets/webpack/bootstrap","webpack://audioworklets/webpack/runtime/define property getters","webpack://audioworklets/webpack/runtime/hasOwnProperty shorthand","webpack://audioworklets/webpack/runtime/make namespace object","webpack://audioworklets/webpack/before-startup","webpack://audioworklets/webpack/startup","webpack://audioworklets/webpack/after-startup"],"sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nexports.__esModule = true;\nvar audioworklets_1 = require(\"@webpd/audioworklets\");\nvar BIT_DEPTH = 64;\nvar CHANNEL_COUNT = 1;\nvar WASM_PATCHES = {\n    'osc': null,\n    'play-array': null\n};\nvar SAMPLES = {\n    'audio1': null\n};\nvar startButton = document.querySelector('button#start');\nvar patchesDiv = document.querySelector('div#patches');\nvar context = new AudioContext();\nvar wasmNode;\nvar initializeApp = function () { return __awaiter(void 0, void 0, void 0, function () {\n    var patchNames, _i, patchNames_1, name_1, _a, _b, button, sampleNames, _c, sampleNames_1, name_2, _d, _e;\n    return __generator(this, function (_f) {\n        switch (_f.label) {\n            case 0: return [4 /*yield*/, (0, audioworklets_1.addModule)(context, audioworklets_1.audioworkletWasm.WorkletProcessorCode)\n                // Load wasm patches\n            ];\n            case 1:\n                _f.sent();\n                patchNames = Object.keys(WASM_PATCHES);\n                _i = 0, patchNames_1 = patchNames;\n                _f.label = 2;\n            case 2:\n                if (!(_i < patchNames_1.length)) return [3 /*break*/, 5];\n                name_1 = patchNames_1[_i];\n                _a = WASM_PATCHES;\n                _b = name_1;\n                return [4 /*yield*/, loadWasmPatch(name_1)];\n            case 3:\n                _a[_b] = _f.sent();\n                button = document.createElement('button');\n                button.innerHTML = name_1;\n                button.onclick = (function (name) {\n                    return function () {\n                        setWasmPatch(name);\n                    };\n                })(name_1);\n                patchesDiv.appendChild(button);\n                _f.label = 4;\n            case 4:\n                _i++;\n                return [3 /*break*/, 2];\n            case 5:\n                sampleNames = Object.keys(SAMPLES);\n                _c = 0, sampleNames_1 = sampleNames;\n                _f.label = 6;\n            case 6:\n                if (!(_c < sampleNames_1.length)) return [3 /*break*/, 9];\n                name_2 = sampleNames_1[_c];\n                _d = SAMPLES;\n                _e = name_2;\n                return [4 /*yield*/, loadAudioSample(name_2)];\n            case 7:\n                _d[_e] = _f.sent();\n                _f.label = 8;\n            case 8:\n                _c++;\n                return [3 /*break*/, 6];\n            case 9: return [2 /*return*/];\n        }\n    });\n}); };\nvar startAudio = function () {\n    context.resume();\n    wasmNode = new audioworklets_1.audioworkletWasm.WorkletNode(context, CHANNEL_COUNT, BIT_DEPTH);\n    wasmNode.connect(context.destination);\n    startButton.style.display = 'none';\n};\nvar loadWasmPatch = function (name) { return __awaiter(void 0, void 0, void 0, function () {\n    var url, response;\n    return __generator(this, function (_a) {\n        switch (_a.label) {\n            case 0:\n                url = \"assets/wasm/\".concat(name, \".wasm\");\n                return [4 /*yield*/, fetch(url)];\n            case 1:\n                response = _a.sent();\n                if (!response.ok) {\n                    throw new Error(\"unvalid response for \".concat(url, \": \").concat(response.status));\n                }\n                return [2 /*return*/, response.arrayBuffer()];\n        }\n    });\n}); };\nvar loadAudioSample = function (name) { return __awaiter(void 0, void 0, void 0, function () {\n    var url, response, audioData, audioBuffer;\n    return __generator(this, function (_a) {\n        switch (_a.label) {\n            case 0:\n                url = \"assets/audio/\".concat(name, \".mp3\");\n                return [4 /*yield*/, fetch(url)];\n            case 1:\n                response = _a.sent();\n                if (!response.ok) {\n                    throw new Error(\"unvalid response for \".concat(url, \": \").concat(response.status));\n                }\n                return [4 /*yield*/, response.arrayBuffer()];\n            case 2:\n                audioData = _a.sent();\n                return [4 /*yield*/, context.decodeAudioData(audioData)\n                    // !!! Loading only first channel of stereo audio\n                ];\n            case 3:\n                audioBuffer = _a.sent();\n                // !!! Loading only first channel of stereo audio\n                return [2 /*return*/, Float64Array.from(audioBuffer.getChannelData(0))];\n        }\n    });\n}); };\nvar setWasmPatch = function (name) {\n    var wasmPatch = WASM_PATCHES[name];\n    if (wasmPatch) {\n        console.log(\"set wasm patch \".concat(name, \" : byte length \").concat(wasmPatch.byteLength));\n        wasmNode === null || wasmNode === void 0 ? void 0 : wasmNode.port.postMessage({\n            type: 'WASM', payload: {\n                wasmBuffer: wasmPatch, arrays: SAMPLES\n            }\n        });\n    }\n};\ninitializeApp().then(function () {\n    startButton.style.display = 'block';\n    startButton.onclick = startAudio;\n    console.log(\"audio initialized\");\n});\n","class JsEvalNode extends AudioWorkletNode {\n    constructor(context, channelCount) {\n        super(context, 'js-eval-node', {\n            numberOfOutputs: 1,\n            outputChannelCount: [channelCount],\n            processorOptions: {\n                sampleRate: context.sampleRate\n            },\n        });\n    }\n}\n\nvar _WorkletProcessorCode$1 = \"/*\\n * Copyright (c) 2012-2020 Sébastien Piquemal <sebpiq@gmail.com>\\n *\\n * BSD Simplified License.\\n * For information on usage and redistribution, and for a DISCLAIMER OF ALL\\n * WARRANTIES, see the file, \\\"LICENSE.txt,\\\" in this distribution.\\n *\\n * See https://github.com/sebpiq/WebPd_pd-parser for documentation\\n *\\n */\\n\\nclass JsEvalWorkletProcessor extends AudioWorkletProcessor {\\n    constructor(settings) {\\n        super()\\n        this.port.onmessage = this.onMessage.bind(this)\\n        this.settings = {\\n            channelCount: settings.outputChannelCount[0],\\n            sampleRate: \\n                settings.processorOptions.sampleRate,\\n        }\\n        this.dspConfigured = false\\n    }\\n\\n    process(_, outputs) {\\n        const output = outputs[0]\\n        if (!this.dspConfigured) {\\n            if (!this.engine) {\\n                return true\\n            }\\n            this.settings.blockSize = output[0].length\\n            this.engine.configure(\\n                this.settings.sampleRate,\\n                this.settings.blockSize,\\n            )\\n            this.dspConfigured = true\\n        }\\n        this.engine.loop(output)\\n        return true\\n    }\\n\\n    onMessage(message) {\\n        switch (message.data.type) {\\n            case 'CODE':\\n                this.setCode(message.data.payload.code)\\n                this.setArrays(message.data.payload.arrays)\\n                break\\n            case 'PORT':\\n                this.callPort(\\n                    message.data.payload.portName,\\n                    message.data.payload.args\\n                )\\n                break\\n            default:\\n                new Error(`unknown message type ${message.type}`)\\n        }\\n    }\\n\\n    setCode(code) {\\n        this.engine = new Function(code)()\\n        this.dspConfigured = false\\n    }\\n\\n    setArrays(arrays) {\\n        Object.entries(arrays).forEach(([arrayName, array]) => {\\n            this.engine.setArray(arrayName, array)\\n        })\\n    }\\n\\n    callPort(portName, args) {\\n        if (!this.engine || !this.engine.ports[portName]) {\\n            throw new Error(`Unknown port ${portName}`)\\n        }\\n        this.engine.ports[portName].apply(this, args)\\n    }\\n}\\n\\nregisterProcessor('js-eval-node', JsEvalWorkletProcessor)\\n\";\n\nconst WorkletProcessorCode$1 = _WorkletProcessorCode$1;\n\nvar index$1 = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    WorkletProcessorCode: WorkletProcessorCode$1,\n    WorkletNode: JsEvalNode\n});\n\nclass WasmWorkletNode extends AudioWorkletNode {\n    constructor(context, channelCount, bitDepth = 32) {\n        super(context, 'wasm-node', {\n            numberOfOutputs: 1,\n            outputChannelCount: [channelCount],\n            processorOptions: {\n                bitDepth, sampleRate: context.sampleRate\n            },\n        });\n    }\n}\n\nvar _WorkletProcessorCode = \"/*\\n * Copyright (c) 2012-2020 Sébastien Piquemal <sebpiq@gmail.com>\\n *\\n * BSD Simplified License.\\n * For information on usage and redistribution, and for a DISCLAIMER OF ALL\\n * WARRANTIES, see the file, \\\"LICENSE.txt,\\\" in this distribution.\\n *\\n * See https://github.com/sebpiq/WebPd_pd-parser for documentation\\n *\\n */\\n\\nclass WasmWorkletProcessor extends AudioWorkletProcessor {\\n    constructor(settings) {\\n        super()\\n        this.port.onmessage = this.onMessage.bind(this)\\n        this.settings = {\\n            blockSize: null,\\n            channelCount: settings.outputChannelCount[0],\\n            bitDepth:\\n                settings.processorOptions.bitDepth,\\n            sampleRate: \\n                settings.processorOptions.sampleRate,\\n        }\\n        this.dspConfigured = false\\n        this.engine = null\\n    }\\n\\n    process(_, outputs) {\\n        const output = outputs[0]\\n        if (!this.dspConfigured) {\\n            if (!this.engine) {\\n                return true\\n            }\\n            this.settings.blockSize = output[0].length\\n            this.wasmOutputPointer = this.engine.configure(\\n                this.settings.sampleRate,\\n                this.settings.blockSize,\\n            )\\n            this.dspConfigured = true\\n        }\\n\\n        const wasmOutput = this.engine.loop()\\n        for (let channel = 0; channel < this.settings.channelCount; channel++) {\\n            output[channel].set(\\n                wasmOutput.subarray(\\n                    this.settings.blockSize * channel,\\n                    this.settings.blockSize * (channel + 1)\\n                )\\n            )\\n        }\\n        return true\\n    }\\n\\n    onMessage(message) {\\n        switch (message.data.type) {\\n            case 'WASM':\\n                this.setWasm(message.data.payload.wasmBuffer)\\n                    .then(() => this.setArrays(message.data.payload.arrays))\\n                break\\n            default:\\n                new Error(`unknown message type ${message.type}`)\\n        }\\n    }\\n\\n    // TODO : control for channelCount of wasmModule\\n    setWasm(wasmBuffer) {\\n        return AssemblyscriptWasmBindings.createEngine(wasmBuffer, {\\n            bitDepth: this.settings.bitDepth,\\n            portSpecs: {},\\n        }).then(engine => {\\n            this.dspConfigured = false\\n            this.engine = engine\\n        })\\n    }\\n\\n    setArrays(arrays) {\\n        Object.entries(arrays).forEach(([arrayName, arrayData]) => {\\n            if ((this.settings.bitDepth === 32 && arrayData.constructor !== Float32Array) \\n                || (this.settings.bitDepth === 64 && arrayData.constructor !== Float64Array)) {\\n                console.error(`Received invalid array ${arrayName} : ${arrayData.constructor}, wrong type for bit-depth ${this.bitDepth}`)\\n                return\\n            }\\n            this.engine.setArray(arrayName, arrayData)\\n        })\\n    }\\n}\\n\\nregisterProcessor('wasm-node', WasmWorkletProcessor)\\n\";\n\nvar AssemblyscriptWasmBindingsCode = \"var AssemblyscriptWasmBindings = (function (exports) {\\n    'use strict';\\n\\n    const INT_ARRAY_BYTES_PER_ELEMENT = Int32Array.BYTES_PER_ELEMENT;\\n    class AssemblyScriptWasmEngine {\\n        constructor(wasmBuffer, settings) {\\n            this.wasmBuffer = wasmBuffer;\\n            this.settings = settings;\\n        }\\n        async initialize() {\\n            const wasmModule = await this._instantiateWasmModule();\\n            this.wasmExports = wasmModule.instance\\n                .exports;\\n            this.ports = this._bindPorts();\\n        }\\n        configure(sampleRate, blockSize) {\\n            this.wasmOutputPointer = this.wasmExports.configure(sampleRate, blockSize);\\n        }\\n        loop() {\\n            this.wasmExports.loop();\\n            return this.liftTypedArray(this.settings.bitDepth === 32 ? Float32Array : Float64Array, this.wasmOutputPointer);\\n        }\\n        setArray(arrayName, data) {\\n            if (!this.wasmExports.setArray) {\\n                console.warn(`Wasm exports doesn't define \\\"setArray\\\"`);\\n                return;\\n            }\\n            const stringPointer = this.lowerString(arrayName);\\n            const bufferPointer = this.lowerArrayBufferOfFloats(data);\\n            this.wasmExports.setArray(stringPointer, bufferPointer);\\n        }\\n        liftMessage(messagePointer) {\\n            const messageDatumTypesPointer = this.wasmExports.getMessageDatumTypes(messagePointer);\\n            const messageDatumTypes = this.liftTypedArray(Int32Array, messageDatumTypesPointer);\\n            const message = [];\\n            messageDatumTypes.forEach((datumType, datumIndex) => {\\n                if (datumType ===\\n                    this.wasmExports.MESSAGE_DATUM_TYPE_FLOAT.valueOf()) {\\n                    message.push(this.wasmExports.readFloatDatum(messagePointer, datumIndex));\\n                }\\n                else if (datumType ===\\n                    this.wasmExports.MESSAGE_DATUM_TYPE_STRING.valueOf()) {\\n                    const stringPointer = this.wasmExports.readStringDatum(messagePointer, datumIndex);\\n                    message.push(this.liftString(stringPointer));\\n                }\\n            });\\n            return message;\\n        }\\n        lowerMessage(message) {\\n            const messageTemplate = message.reduce((template, value) => {\\n                if (typeof value === 'number') {\\n                    template.push(this.wasmExports.MESSAGE_DATUM_TYPE_FLOAT.valueOf());\\n                }\\n                else if (typeof value === 'string') {\\n                    template.push(this.wasmExports.MESSAGE_DATUM_TYPE_STRING.valueOf());\\n                    template.push(value.length);\\n                }\\n                else {\\n                    throw new Error(`invalid message value ${value}`);\\n                }\\n                return template;\\n            }, []);\\n            const messagePointer = this.wasmExports.createMessage(this.lowerArrayBufferOfIntegers(messageTemplate));\\n            message.forEach((value, index) => {\\n                if (typeof value === 'number') {\\n                    this.wasmExports.writeFloatDatum(messagePointer, index, value);\\n                }\\n                else if (typeof value === 'string') {\\n                    const stringPointer = this.lowerString(value);\\n                    this.wasmExports.writeStringDatum(messagePointer, index, stringPointer);\\n                }\\n            });\\n            return messagePointer;\\n        }\\n        lowerMessageArray(messages) {\\n            const messageArrayPointer = this.wasmExports.createMessageArray();\\n            messages.forEach((message) => {\\n                this.wasmExports.pushMessageToArray(messageArrayPointer, this.lowerMessage(message));\\n            });\\n            return messageArrayPointer;\\n        }\\n        lowerArrayBufferOfIntegers(integers) {\\n            const buffer = new ArrayBuffer(INT_ARRAY_BYTES_PER_ELEMENT * integers.length);\\n            const dataView = new DataView(buffer);\\n            for (let i = 0; i < integers.length; i++) {\\n                dataView.setInt32(INT_ARRAY_BYTES_PER_ELEMENT * i, integers[i]);\\n            }\\n            return this.lowerBuffer(buffer);\\n        }\\n        lowerArrayBufferOfFloats(floats) {\\n            const bytesPerElement = this.settings.bitDepth / 8;\\n            const buffer = new ArrayBuffer(bytesPerElement * floats.length);\\n            const dataView = new DataView(buffer);\\n            const setFloatName = this.settings.bitDepth === 32 ? 'setFloat32' : 'setFloat64';\\n            for (let i = 0; i < floats.length; i++) {\\n                dataView[setFloatName](bytesPerElement * i, floats[i]);\\n            }\\n            return this.lowerBuffer(buffer);\\n        }\\n        liftTypedArray(constructor, pointer) {\\n            if (!pointer)\\n                return null;\\n            const memoryU32 = new Uint32Array(this.wasmExports.memory.buffer);\\n            return new constructor(this.wasmExports.memory.buffer, memoryU32[(pointer + 4) >>> 2], memoryU32[(pointer + 8) >>> 2] / constructor.BYTES_PER_ELEMENT).slice();\\n        }\\n        liftString(pointer) {\\n            if (!pointer)\\n                return null;\\n            pointer = pointer >>> 0;\\n            const end = (pointer +\\n                new Uint32Array(this.wasmExports.memory.buffer)[(pointer - 4) >>> 2]) >>>\\n                1;\\n            const memoryU16 = new Uint16Array(this.wasmExports.memory.buffer);\\n            let start = pointer >>> 1;\\n            let string = '';\\n            while (end - start > 1024) {\\n                string += String.fromCharCode(...memoryU16.subarray(start, (start += 1024)));\\n            }\\n            return string + String.fromCharCode(...memoryU16.subarray(start, end));\\n        }\\n        lowerString(value) {\\n            if (value == null)\\n                return 0;\\n            const length = value.length, pointer = this.wasmExports.__new(length << 1, 1) >>> 0, memoryU16 = new Uint16Array(this.wasmExports.memory.buffer);\\n            for (let i = 0; i < length; ++i)\\n                memoryU16[(pointer >>> 1) + i] = value.charCodeAt(i);\\n            return pointer;\\n        }\\n        lowerBuffer(value) {\\n            if (value == null)\\n                return 0;\\n            const pointer = this.wasmExports.__new(value.byteLength, 0) >>> 0;\\n            new Uint8Array(this.wasmExports.memory.buffer).set(new Uint8Array(value), pointer);\\n            return pointer;\\n        }\\n        _bindPorts() {\\n            const ports = {};\\n            const wasmExports = this.wasmExports;\\n            Object.entries(this.settings.portSpecs).forEach(([variableName, spec]) => {\\n                if (spec.access.includes('w')) {\\n                    if (spec.type === 'messages') {\\n                        ports[`write_${variableName}`] = (messages) => {\\n                            const messageArrayPointer = this.lowerMessageArray(messages);\\n                            wasmExports[`write_${variableName}`](messageArrayPointer);\\n                        };\\n                    }\\n                    else {\\n                        ports[`write_${variableName}`] =\\n                            wasmExports[`write_${variableName}`];\\n                    }\\n                }\\n                if (spec.access.includes('r')) {\\n                    if (spec.type === 'messages') {\\n                        ports[`read_${variableName}`] = () => {\\n                            const messagesCount = wasmExports[`read_${variableName}_length`]();\\n                            const messages = [];\\n                            for (let i = 0; i < messagesCount; i++) {\\n                                const messagePointer = wasmExports[`read_${variableName}_elem`](i);\\n                                messages.push(this.liftMessage(messagePointer));\\n                            }\\n                            return messages;\\n                        };\\n                    }\\n                    else {\\n                        ports[`read_${variableName}`] =\\n                            wasmExports[`read_${variableName}`];\\n                    }\\n                }\\n            });\\n            return ports;\\n        }\\n        async _instantiateWasmModule() {\\n            const wasmModule = await WebAssembly.instantiate(this.wasmBuffer, {\\n                env: {\\n                    abort: (messagePointer, fileNamePointer, lineNumber, columnNumber) => {\\n                        const message = this.liftString(messagePointer >>> 0);\\n                        const fileName = this.liftString(fileNamePointer >>> 0);\\n                        lineNumber = lineNumber >>> 0;\\n                        columnNumber = columnNumber >>> 0;\\n                        (() => {\\n                            throw Error(`${message} in ${fileName}:${lineNumber}:${columnNumber}`);\\n                        })();\\n                    },\\n                    seed: () => {\\n                        return (() => {\\n                            return Date.now() * Math.random();\\n                        })();\\n                    },\\n                    'console.log': (textPointer) => {\\n                        console.log(this.liftString(textPointer));\\n                    },\\n                },\\n            });\\n            return wasmModule;\\n        }\\n    }\\n    const createEngine = async (wasmBuffer, settings) => {\\n        const engine = new AssemblyScriptWasmEngine(wasmBuffer, settings);\\n        await engine.initialize();\\n        return engine;\\n    };\\n\\n    exports.AssemblyScriptWasmEngine = AssemblyScriptWasmEngine;\\n    exports.INT_ARRAY_BYTES_PER_ELEMENT = INT_ARRAY_BYTES_PER_ELEMENT;\\n    exports.createEngine = createEngine;\\n\\n    Object.defineProperty(exports, '__esModule', { value: true });\\n\\n    return exports;\\n\\n})({});\\n//# sourceMappingURL=assemblyscript-wasm-bindings.iife.js.map\\n\";\n\nconst WorkletProcessorCode = AssemblyscriptWasmBindingsCode + ';\\n' + _WorkletProcessorCode;\n\nvar index = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    WorkletProcessorCode: WorkletProcessorCode,\n    WorkletNode: WasmWorkletNode\n});\n\nconst addModule = async (context, processorCode) => {\n    const blob = new Blob([processorCode], { type: 'text/javascript' });\n    const workletProcessorUrl = URL.createObjectURL(blob);\n    return context.audioWorklet.addModule(workletProcessorUrl);\n};\n\nexport { addModule, index$1 as audioworkletJsEval, index as audioworkletWasm };\n//# sourceMappingURL=index.js.map\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./src/index.ts\");\n",""],"names":[],"sourceRoot":""}